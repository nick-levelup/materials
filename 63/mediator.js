// Шаблон Mediator (Посредник)

/*
В разделе про шаблон Observer (Наблюдатель), нам было предоставленн путь общения между несколькими источниками событий с помощью одного объекта. Это также известно как Publish/Subscribe (Издатель/Подписчик) или Event Aggregation (Агрегатор событий). Это распространнено среди разработчиков рамышлять про шаблон Посредник, когда они сталкиваются с этой проблемой, так что давайте посмотрим, чем они отличаются.

Словарь дает пояснения посреднику как "нейтральной сторона, которая помогает в переговорах и разрешении конфликтов". В нашем мире, посредник это поведенческих шаблон, который позволяет выстроить единый интерфейс, через который различные части системы могут взаимодействовать.

Если случаеться что система имеет слишком много прямых связей между компонентами, самое время создать центральную точку контроля через которую будут они общатся. Посредник способствует ослаблению связей, гарантируя, что вместо компонентов, относящихся друг к другу явно, их взаимодействие осуществляется через этот центральный пункт. Это может помочь нам отделить системы и улучшить потенциал для повторного использования компонента.

В реальном мире аналогия может быть типичная система управления движением аэропорта. Башня (Посредник) обрабатывает то, что самолеты могут взлетать и садиться, потому что все коммуникации передаются из самолетов к контрольной башне, а не от самолета к самолету. Централизованный контроллер является ключом к успеху этой системы, и эту роль играет посредник в разработке программного обеспечения.

Другая аналогия это всплытие и делегация событий в DOM. Если все подписки в системе выполнены через  документ, а не через отдельные узлы, документ эффективно служит в качестве посредника. Вместо того, чтобы связываться с событиями отдельных узлов, на объект который находиться уровнем выше возложена ответственность за уведомление абонентов о событиях взаимодействий.

Когда дело доходит до Посредника и агрегатора событий, иногла случаеться так что патерны взаимозаменяемы из-за сходства реализации. Тем не менее, семантика и намерения этих паттернов очень разные.

И даже если обе реализации используют некоторые из тех же основных конструкций, я думаю, что есть определенная разница между ними. Я также считаю, что они не должны быть взаимозаменяемыми или смешивать в связи из-за разногласий.

Простой Посредник

Посредник это объект, который координирует взаимодействия (логику и поведение) между несколькими объектами. Он решает, когда вызывать какие объекты, основываясь на действиях (или бездействий) других объектов и источников.

Вы можете написать посредника, используя одну строку кода:
*/

var mediator = {};

/*
Да, конечно, это просто литерал объекта в JavaScript. Опять же, мы говорим о семантике здесь.Цель посредника это контроль рабочего процесса между объектами, и нам действительно не нужно ничего больше, чем литерал объекта что бы его реализавать.
*/

var orgChart = {
 
  addNewEmployee: function(){
 
    // getEmployeeDetail provides a view that users interact with
    var employeeDetail = this.getEmployeeDetail();
 
    // when the employee detail is complete, the mediator (the 'orgchart' object)
    // decides what should happen next
    employeeDetail.on("complete", function(employee){
 
      // set up additional objects that have additional events, which are used
      // by the mediator to do additional things
      var managerSelector = this.selectManager(employee);
      managerSelector.on("save", function(employee){
        employee.save();
      });
 
    });
  },
 
  // ...
}

/*
Этот пример показывает очень базовую реализацию объекта-посредника с некоторыми утилитными методами, которая может вызвать и подписаться на события.

Я часто называют этого типа объекта "workflow", правда в том, что он является посредником. Это объект, который создает рабочий процесс между многими другими объектами, агрегирования ответственность этого знания в одном объекте.Результат этот код легче понять и поддерживать.

Сходства и различия

Есть, без сомнения, сходство между агрегатором событий и паттерном посредник. Сходство сводятся к двум основным пунктам: события и сторонние объекты. Эти различия являются поверхностными, в лучшем, хотя. Когда мы копаем в намерениях паттерна и видем, что реализация может значительно отличается, сущность паттернов становится все более очевидным.

События

Оба, и агрегатор событий и посредник используют события, в приведенных выше примерах. Агрегатор событий, очевидно, имеет дело с событиями - это отражена в его имени. Посредник использует только события, потому что это облегчает жизнь при работе с современными JavaScript в рамках Веб-приложения. Никто не говорит что посредник должен быть построен на событияч. Можно построить медиатор на методах обратного вызова, путем передачи ссылки посредника для дочернего объекта, или с помощью любого ряда других средств.

Разница в том, почему оба этих паттернов, используют  события. Агрегатор событий, как паттерн, предназначен для работы с событиями. Посредник, использует их, только потому что это удобно.
*/

var MenuItem = MyFrameworkView.extend({
 
  events: {
    "click .thatThing": "clickedIt"
  },
 
  clickedIt: function(e){
    e.preventDefault();
 
    // assume this triggers "menu:click:foo"
    MyFramework.trigger("menu:click:" + this.model.get("name"));
  }
 
});
 
// ... somewhere else in the app
 
var MyWorkflow = function(){
  MyFramework.on("menu:click:foo", this.doStuff, this);
};
 
MyWorkflow.prototype.doStuff = function(){
  // instantiate multiple objects here.
  // set up event handlers for those objects.
  // coordinate all of the objects into a meaningful workflow.
};
