// https://regex101.com/
// Регулярные выражения –- мощное средство поиска и замены в строке.

// «регэксп», «регулярка» или просто «рег»
// шаблон, паттерн

var regexp = new RegExp("шаблон"); // без флагов
var regexp = new RegExp("шаблон", "gmi"); // с флагами gmi

var regexp = /шаблон/; // без флагов
var regexp = /шаблон/gmi; // с флагами gmi

/*
i
Если этот флаг есть, то регэксп ищет независимо от регистра,
то есть не различает между А и а.

g
Если этот флаг есть, то регэксп ищет все совпадения,
иначе — только первое.

m
Многострочный режим.
*/

// Регулярные выражения в JavaScript являются объектами класса RegExp. 

// методы для поиска по регулярным выражениям встроены прямо в
// обычные строки String.


/* ======== */
str.search(reg)
// возвращает позицию первого совпадения или -1, если ничего не найдено.
// Ограничение метода search — он всегда ищет только первое совпадение.

// Task
// найти Java в строке "Я люблю JavaScript!"
// найти Java без учета регистра в строке "Я люблю JavaScript!"

/* ======== */
str.match(reg) // без флага g
/*
находит только одно, первое совпадение.

Результат вызова — это массив, состоящий из этого совпадения,
с дополнительными свойствами index — позиция, на которой оно
обнаружено и input — строка, в которой был поиск.
*/

var str = "ОЙ-Ой-ой";

var result = str.match( /ой/i );

alert( result[0] ); // ОЙ  (совпадение)
alert( result.index ); // 0 (позиция)
alert( result.input ); // ОЙ-Ой-ой (вся поисковая строка)

/*
Если часть шаблона обозначена скобками,
то она станет отдельным элементом массива.
*/

var str = "javascript - это такой язык";

var result = str.match( /JAVA(SCRIPT)/i );

alert( result[0] ); // javascript (всё совпадение полностью)
alert( result[1] ); // script (часть совпадения, соответствующая скобкам)
alert( result.index ); // 0
alert( result.input ); // javascript - это такой язык

/* ======== */
str.match(reg) // с флагом g
/* возвращает обычный массив из всех совпадений. */

var str = "ОЙ-Ой-ой";

var result = str.match( /ой/ig );

alert( result ); // ОЙ, Ой, ой

// ! В случае, если совпадений не было, match возвращает null

/* ======== */
str.split(reg|substr, limit) // Разбивает строку в массив по разделителю

alert('12-34-56'.split('-')) // [12, 34, 56]
alert('12-34-56'.split(/-/)) // [12, 34, 56]

/* ======== */
str.replace(reg, str|func) // поиска и замены любого уровня сложности

// заменить дефис на двоеточие
// При вызове со строкой замены replace всегда заменяет
// только первое совпадение.

alert('12-34-56'.replace("-", ":")) // 12:34-56

// заменить дефис на двоеточие
alert( '12-34-56'.replace( /-/g, ":" ) )  // 12:34:56

var str = "Василий Пупкин";
alert(str.replace(/Василий Пупкин/, 'Великий $&!')) // Великий Василий Пупкин

var str = "Василий Пупкин";
alert(str.replace(/(Василий) (Пупкин)/, '$2, $1')) // Пупкин, Василий

/*
$$  Вставляет "$".
$&  Вставляет всё найденное совпадение.
$`  Вставляет часть строки до совпадения.
$'  Вставляет часть строки после совпадения.
$*n*  где n — цифра или двузначное число, обозначает n-ю
по счёту скобку, если считать слева-направо.
*/


/*
Для ситуаций, который требуют максимально «умной» замены,
в качестве второго аргумента предусмотрена функция.


str — найденное совпадение,
p1, p2, ..., pn — содержимое скобок (если есть),
offset — позиция, на которой найдено совпадение,
s — исходная строка.

Если скобок в регулярном выражении нет,
то у функции всегда будет ровно 3 аргумента:
replacer(str, offset, s).

*/


/* ======== */
regexp.test(str)
str.search(reg) != -1
// Метод test проверяет, есть ли хоть одно совпадение
//в строке str. Возвращает true/false.


/* ======== */
regexp.exec(str)
// позволяет искать и все совпадения и скобочные группы в них.
/*
Он ведёт себя по-разному, в зависимости от того, есть ли у
регэкспа флаг g.

Если флага g нет, то regexp.exec(str) ищет и возвращает
первое совпадение, является полным аналогом вызова str.match(reg).

Если флаг g есть, то вызов regexp.exec возвращает первое
совпадение и запоминает его позицию в свойстве regexp.lastIndex.
Последующий поиск он начнёт уже с этой позиции.
Если совпадений не найдено, то сбрасывает regexp.lastIndex в ноль.

*/



// Поиск с нужной позиции
var regexp = /javascript/ig;
regexp.lastIndex = 40;

alert( regexp.exec(str).index ); // 49, поиск начат с 40й позиции


/*

Для поиска только одного совпадения:

        Найти позицию первого совпадения — str.search(reg).
        Найти само совпадение — str.match(reg).
        Проверить, есть ли хоть одно совпадение — regexp.test(str)
        или str.search(reg) != -1.
        Найти совпадение с нужной позиции — regexp.exec(str),
        начальную позицию поиска задать в regexp.lastIndex.

Для поиска всех совпадений:

        Найти массив совпадений — str.match(reg), с флагом g.
        Получить все совпадения, с подробной информацией о каждом —
        regexp.exec(str) с флагом g, в цикле.

Для поиска-и-замены:

        Замена на другую строку или функцией —
        str.replace(reg, str|func)

Для разбивки строки на части:

        str.split(str|reg)


*/

// Классы

/*

\d (от английского «digit» — «цифра»)
    Цифра, символ от 0 до 9.

\s (от английского «space» — «пробел»)
    Пробельный символ, включая табы, переводы строки и т.п.

\w (от английского «word» — «слово»)
    Символ «слова», а точнее — буква латинского алфавита или
    цифра или подчёркивание '_'. Не-английские буквы не являются
    \w, то есть русская буква не подходит.
*/

/\d\s\w/

/CSS\d/

/*
Граница слова \b

Например, \bJava\b найдёт слово Java в строке Hello,
Java!, но не в строке Hello, Javascript!.
*/