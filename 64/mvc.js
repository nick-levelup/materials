/*
MVC представляет собой паттерн проектирования архитектуры, который 
улучшает структуру приложения путем разделения его задач.
Он позволяет изолировать бизнес-данные (модели) от пользовательских интерфейсов 
(представлений) с помощью третьего компонента (контроллеров), который 
управляет логикой и вводом пользовательских данных, а также координирует 
модели и представления.
*/

/*
паттерн наблюдателя был частью архитектуры MVC несколько десятилетий назад.
Простой пример этого
подхода
— приложение для фондовой биржи: чтобы оно могло отображать информацию в реальном времени,
любое изменение данных в его модели должно приводить к немедленному обновлению представления.
*/

// http://codebox.in/blog/wp-content/uploads/2014/06/MVC-framework-for-PHP-development.png

/*
Когда контроллер запросов получает HTTP-запрос, он анализирует его и 
принимает решение о том, какой класс (контроллер) и метод (действие) вызвать. 
Выбранное действие контроллера получает управление и взаимодействует 
с соответствующей моделью для выполнения запроса. Контроллер получает 
данные от модели, загружает соответствующее представление, вставляет в него 
данные модели и возвращает ответ браузеру.

http://www.example.com/article/edit/43
*/

// MVC на клиентской стороне и одностраничные приложения

// сокращение задержек
// повторной передаче пользователю большого объема данных
// одностраничные приложения


/*
Модели

Встроенные возможности моделей изменяются в зависимости от фрейм ворка;
тем не менее модели обычно поддерживают валидацию атрибутов, 
где атрибуты представляют свойства модели, например ее идентификатор.

При использовании моделей в реальных приложениях нам, как правило, 
требуется сохранять их. Это дает возможность редактировать и обновлять 
модели, зная при этом, что их последние состояния будут сохранены, на пример,
в локальном хранилище веб-браузера или синхронизованы с базой 
данных.

За изменениями одной модели могут одновременно наблюдать несколько  представлений. Под 
наблюдением я понимаю состояние, в котором пред ставление зарегистрировало свою
«заинтересованность» в получении уведомлений об обновлении модели.
Это позволяет представлению гаран тировать, что информация, отображаемая на экране,
соответствует данным, содержащимся в модели. В зависимости от требований вы можете создать 
как единственное представление, отображающее все атрибуты модели, так 
и несколько представлений, отображающих различные атрибуты. Здесь 
важно то, что модель не имеет отношения к тому, как организованы эти представления;
она просто посылает уведомления о том, что ее данные 
обновились, через систему событий фреймворка.

Коллекции
Современные MVC/MV*-фреймворки нередко предоставляют способы 
группировки моделей. такие группы называются  коллекциями

Управление моделями в группах позволяет создавать логику приложения на 
основе уведомлений, поступающих от группы, когда модель внутри группы 
изменяется. Это устраняет необходимость отслеживать состояния отдель ных моделей вручную.

Коллекции также полезны при выполнении сводных вычислений с участием 
нескольких моделей.

Представления

Как правило, пользователи взаимодействуют с представлениями, считывая 
и редактируя данные модели.
*/

/*
Большинство JavaScript-фреймворков, реализующих паттерн MVC, отклоня ется от
его традиционной интерпретации в том, что касается контроллеров. 
Этому есть ряд причин, но мне кажется, что авторы JavaScript-фреймворков, 
изучая серверные интерпретации MVC (такие, как Ruby on Rails), приходили 
к выводу, что их нельзя в точности повторить на клиентской стороне, и 
поновому реализовывали контроллеры, чтобы решить проблему управления 
состоянием приложения. Это разумный подход, однако из-за него разработчикам,
впервые использующим MVC, может быть сложно одновременно 
понять классический паттерн MVC и особую роль контроллеров в других 
JavaScript-фреймворках
*/

/*
паттерн MVC помогает разделять логику приложения и пользовательский интерфейс,
упрощая модификацию и поддержку и того и другого. 
Благодаря такому разделению разработчику гораздо легче понять, где вносить 
изменения в данные, интерфейсы и бизнес-логику приложения и что должны 
проверять модульные тесты
*/